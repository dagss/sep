SEP 200 - Extensible type objects ("C-level duck typing")
=========================================================

======   ====================
Author   Dag Sverre Seljebotn
Status   Draft
======   ====================


Overview
--------

Often Python extensions needs to communicate things on the ABI level
about Python objects. In essence, one would like more slots in
``PyTypeObject`` for a custom purpose. Dictionary lookups are both
impractical, slow, and require the GIL.

The solution today is often to rely on
``PyObject_TypeCheck``. However, this works against standardizing
things across libraries, and creates one-to-many situations (only one
implementor of an API, but many consumers), rather than many-to-many
where there can be multiple implementors and multiple consumers of a
mutually agreed-upon standard (think "domain-specific PEP 3118s").

To overcome this problem, the usual approach is to propose a
PEP. However, that process is a) slow, b) not suitable for very
domain-specific tasks, and c) the result is not backwards-compatible
with earlier versions of Python.

This SEP introduces a metaclass on the C level which can be used to
provide effectively an unlimited number of custom slots in the
``PyTypeObject``, without relying on the normal type inheritance.

Examples uses:

 * Make the NumPy array truly polymorphic at the C level, exporting
   various vtables

 * Implement "fast callables" on the C-level, so that, e.g., Cython
   can call ``np.sin`` from C code with very little overhead, because
   it finds a function pointer with a "dd->d" signature tagged to the
   Python object

 * Standardize the Cython ``cdef class`` vtable

 * Standardize the internal memoryview representation of Cython
   (which is much faster than passing around ``Py_buffer``)


Implementation and lack of runtime dependency
---------------------------------------------

An implementation is available from
https://github.com/dagss/pyextensibletype

The implementation is based on a) a metaclass ``extensibletype``, b) hijacking
bit 22 to denote types with this metaclass in its hierarchy (see discussion).

Having a run-time dependency would be a significant disadvantage.
Instead, each participating provider library should contain the code for the
``extensibletype`` metaclass, provided in a short header file
(``include/extensibletype.h``). Because one needs to compare the
metaclass by reference, each library always checks a central location
for it::

    try:
        extensibletype = sys.modules.setdefault('_extensibletype', {})['extensibletype-v1']
        # succeeded, ignore our own implementation of it
    except KeyError:
        # create it and insert it


The custom slot table
---------------------

The metaclass is used to annotate each participating type with a table
of custom slots::

    typedef struct {
        uint32_t id;
        uint32_t flags;
        void *data;
    } PyCustomSlot;

The ``id`` identifies the purpose of the slot and the ID space is
described further down.  Users querying an object for a C-level
interface scan this custom slot table in its type for IDs they
recognize. If an entry is found, ``data`` contains custom information
(defined by whoever defined the ID). It will often be a pointer to a
vtable, similar to slots like ``tp_as_buffer``, but alternatively it
can be casted to an integer representing an offset that should be
added to the ``PyObject*`` of instances of the type in order to look
up some field.

The ``flags`` field is present to indicate features that are
backwards-compatible, such as appending to a vtable. It is present in
``PyCustomSlot`` because a) it's convenient to skip one layer of
indirection in the case that ``data`` is defined to be an offset on a
``PyObject*``, b) this space would be lost to padding on 64-bit platforms
anyway, c) one could imagine a slot being provided multiple times in
the table with different flags (the current ``...Find`` function
does not support this, but one can access the ``...Table`` directly).

Custom slots are not required to have any order; types are expected to
know which custom slot is most performance critical and put that first
in the list.

Note, however, that a custom slot definition can say that it expects
to be found after a given location. For instance, if the NumPy array
grows four different C vtables, then the last one can indicate that it
should always be found as the 4th slot or later on any type, so that
users can optimize for the common case of NumPy arrays. Other less
featureful array types would then need to pre-pad the table with ID
``0x1`` (see below).  This scheme should mean there's almost never
branch misses for the "typical" usecases, since each group of custom slots
likely to be found together can negotiate on a position in the table
which the branch predictor should assume.


Consumer API
------------

The consumer API is found in ``include/customslots.h``. It is meant to
be forwards-compatible with other ways of implementing the same
concepts (like a PEP), and so doesn't mention the metaclass
explicitly.

All functions can be called without holding the GIL, as long as one
has a guaranteed reference to the type object.

``PyCustomSlots_Check(obj)``
    Does the object support the protocol? Should be checked before using
    any of the other below.

``PyCustomSlots_Count(obj)``
    How many custom slots does the object support?

``PyCustomSlot *PyCustomSlots_Table(obj)``
    Get a pointer to the table

``PyCustomSlot *PyCustomSlots_Find(PyObject *obj, uint32_t id, Py_ssize_t start)``
    Search the table for a matching slot; returns `NULL` if none is found.
    The search happens at the position given by `start`; usually you pass ``0``,
    but if the custom slot is documented to always be found at a location ``>= n``
    in the table, pass in ``n``.

Provider API
------------

The provider API is found in ``include/extensibletype.h``, and
requires detailed knowledge of the implementation mechanism.  To
annotate a type with custom slots, basically read the metaclass source
code and understand it. What changes is the definition of the type
object; the basic steps are:

 * Make the type object a ``PyHeapExtensibleTypeObject``. This is
   a "substruct" of ``PyHeapTypeObject`` rather than ``PyTypeObject``.
   This changes the initialization a little bit but was needed to make
   types subclassable Python side.

 * Set the metaclass (``ob_type`` in the type object)

 * Set ``etp_count`` and ``etp_custom_slots`` to the custom slot table

Relevant snippet from ``demo/provider_c_code.h``::

    PyTypeObject *extensibletype = PyExtensibleType_Import();
    if (!extensibletype) return -1;
    ((PyObject*)&Provider_Type)->ob_type = extensibletype;
    Provider_Type.etp_count = 1;
    Provider_Type.etp_custom_slots = my_custom_slots;


Subclasses
----------

C subclasses must be explicit and care for themselves; we can't make
``PyType_Ready`` magically know about this.

If you subclass a type Python-side ("on the heap"), the metaclass
``tp_new`` kicks in and copies the pointer to the table from the
parent type. This behaviour is coded into the metaclass and is thus
hard to change; but of course code can undo this (with the aid of some
C-level helpers) after the metaclass ``tp_new`` has run.

Benchmark results
-----------------

The penalty of a branch-predicted table lookup in a micro-benchmark
was 1.08 ns on a 1.87 GHz (Intel Core i7 Q 840).

Changing to a format where the table was embedded directly, loosing
one pointer indirection, did not change the numbers at all.  Also,
because the var-object resizeability is already used up for the method
table in heap-allocated types, this would be somewhat intricated.

For the metaclass checking strategy, there was no difference between
only being able to match the metaclass itself, or also having the
possibility of matching a metaclass subclass (as long as that
possibility isn't taken, i.e. the direct match is ``likely``).


The custom slot ID space
------------------------

The most significant 8 bits of the ``uint32_t`` denote a
"registrar". Each registrar determines the use of the remaining 24
bits, but a recommendation, from most to least significant, is:

 * 8 bits: Registrar (required)
 * 16 bits: Which custom slot "idea"
 * 8 bits: Which backwards-incompatible version of the idea

Backwards-compatible changes should be noted in the ``flag`` field
rather than the ID.

When lookup up a slot following this recommendation, one should
therefore ``&`` the ID with the proper mask for the flags,
which is the purpose of the ``mask`` argument to ``PyCustomSlots_Find``
(that is, to match any flags, pass ``0xffffff00``).

Special IDs:

 * 0x00000000: Reserved for now
 * 0x00000001: Use if pre-padding the table is needed

ID space (most significant 8 bits):

 * 0x00: Reserved
 * 0x01-0x0f: For internal/personal use, never use in released libraries
 * 0x10-0x6f: NumFOCUS SEPs, NumPy, SciPy
 * 0x70-0x7f: Cython
 * 0x80-...: Whoever asks


Discussion
----------

Hijacking bit 22 in ``tp_flags`` has the following advantages:

 - Consumers don't have to call any ``PyCustomSlots_Init`` to import
   a reference to the metaclass
 
 - Consumers don't have to carry along a metaclass implementation just
   in case they are imported before the first provider. (Keep in mind
   that if the NumPy C API is refactored to be based on this mechanism,
   there will be a lot of consumers.)

 - It is (probably) microscopically faster if you need to subclass the
   metaclass for some reason. No effect if you're not subclassing the
   metaclass though (due to branch prediction working its wonders)

The disadvantage is of course that we hijack a flag, and we have no guarantee
that other Python libraries are not doing the same.

At any rate, if a new Python version uses all available flag bits (and
this SEP is not accomodated by any PEPs in the meantime), one can
switch to walking ``ob_type`` and ``tp_base`` rather than checking
``tp_flags``.

As for inclusion as a PEP, that only works for new Python versions.
Python-dev was consulted on the question [#]_, and Nick Coghlan's
response [#]_ indicated that a PEP might not be entirely impossible
but should require a working implementation based on meta-classes
first.


.. [#] http://mail.python.org/pipermail/python-dev/2012-May/119481.html
.. [#] http://mail.python.org/pipermail/python-dev/2012-May/119518.html
