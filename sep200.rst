SEP 200 - Extensible type objects ("C-level duck typing")
=========================================================

======   ====================
Author   Dag Sverre Seljebotn
Status   Draft
======   ====================


Overview
--------

Often Python extensions needs to communicate things on the ABI level
about Python objects. In essence, one would like more slots in
``PyTypeObject`` for a custom purpose. Dictionary lookups are both
impractical, slow, and require the GIL.

The solution today is often to rely on
``PyObject_TypeCheck``. However, this works against standardizing
things across libraries, and creates one-to-many situations (only one
implementor of an API, but many consumers), rather than many-to-many
where there can be multiple implementors and multiple consumers of a
mutually agreed-upon standard (think "domain-specific PEP 3118s").

To overcome this problem, the usual approach is to propose a
PEP. However, that process is a) slow, b) not suitable for very
domain-specific tasks, and c) the result is not backwards-compatible
with earlier versions of Python.

This SEP introduces a metaclass on the C level which can be used to
provide effectively an unlimited number of custom slots in the
``PyTypeObject``, without relying on the normal type inheritance.

Examples uses:

 * Make the NumPy array truly polymorphic at the C level, exporting
   various vtables

 * Implement "fast callables" on the C-level, so that, e.g., Cython
   can call ``np.sin`` from C code with very little overhead, because
   it finds a function pointer with a "dd->d" signature tagged to the
   Python object

 * Standardize the Cython ``cdef class`` vtable

 * Standardize the internal memoryview representation of Cython
   (which is much faster than passing around ``Py_buffer``)


Implementation and lack of runtime dependency
---------------------------------------------

An implementation is available from
https://github.com/dagss/pyextensibletype

The implementation is based on a) a metaclass ``extensibletype``, b) hijacking
``tp_flags`` bit 22 to denote types with this metaclass in its hierarchy (see discussion).

Having a run-time dependency would be a significant disadvantage.
Instead, each participating provider library should contain the code for the
``extensibletype`` metaclass, provided in a short header file
(``include/extensibletype.h``). The first such module that gets initialized
puts the metaclass in the ``extensibletype_v1`` in the ``_extensibletype``
module; later modules simply look up the metaclass there.

The custom slot table
---------------------

The metaclass is used to annotate each participating type with a table
of custom slots::

    typedef struct {
        uint32_t id;
        uint32_t flags;
        void *data;
    } PyCustomSlot;

The ``id`` identifies the purpose of the slot and the ID space is
described further down.  Users querying an object for a C-level
interface scan this custom slot table in its type for IDs they
recognize. If an entry is found, ``data`` contains custom information
(defined by whoever defined the ID). It will often be a pointer to a
vtable, similar to slots like ``tp_as_buffer``, but alternatively it
can be casted to an integer representing an offset that should be
added to the ``PyObject*`` of instances of the type in order to look
up some field.

The ``flags`` field is present to indicate features that are
backwards-compatible, such as appending to a vtable. It is present in
``PyCustomSlot`` because a) it's convenient to skip one layer of
indirection in the case that ``data`` is defined to be an offset on a
``PyObject*``, b) this space would be lost to padding on 64-bit platforms
anyway, c) one could imagine a slot being provided multiple times in
the table with different flags (the current ``...Find`` function
does not support this, but one can access the ``...Table`` directly).

Custom slots are not required to have any order; types are expected to
know which custom slot is most performance critical and put that first
in the list.

Note, however, that a custom slot definition can say that it expects
to be found after a given location. For instance, if the NumPy array
grows four different C vtables, then the last one can indicate that it
should always be found as the 4th slot or later on any type, so that
users can optimize for the common case of NumPy arrays. Other less
featureful array types would then need to pre-pad the table with ID
``0x1`` (see below).  This scheme should mean there's almost never
branch misses for the "typical" usecases, since each group of custom slots
likely to be found together can negotiate on a position in the table
which the branch predictor should assume.


Consumer API
------------

The consumer API is found in ``include/customslots.h``. It is meant to
be forwards-compatible with other ways of implementing the same
concepts (like a PEP), and so doesn't mention the metaclass
explicitly.

All functions can be called without holding the GIL, as long as one
has a guaranteed reference to the type object.

``PyCustomSlots_Check(obj)``
    Does the object support the protocol? Should be checked before using
    any of the other below.

``PyCustomSlots_Count(obj)``
    How many custom slots does the object support?

``PyCustomSlot *PyCustomSlots_Table(obj)``
    Get a pointer to the table

``PyCustomSlot *PyCustomSlots_Find(PyObject *obj, uint32_t id, Py_ssize_t start)``
    Search the table for a matching slot; returns `NULL` if none is found.
    The search happens at the position given by `start`; usually you pass ``0``,
    but if the custom slot is documented to always be found at a location ``>= n``
    in the table, pass in ``n``.

Provider API
------------

The provider API is found in ``include/extensibletype.h``, and
requires detailed knowledge of the implementation mechanism.

To allow sub-classing Python side, the "object struct" must be based on
``PyHeapTypeObject`` rather than ``PyTypeObject``.

``static int PyExtensibleType_Ready(PyHeapExtensibleTypeObject *type, Py_ssize_t slot_table_size)``
    Called to initialize a statically allocated extensible type.
    The ``slot_table_size`` is used in the case of subclassing
    another extensible type (see subclassing rules below).

    Before calling this function, ``etp_count`` and ``etp_custom_slots`` should
    be filled in.

    The function a) imports the ``extensibletype`` metaclass and
    sets ``type->ob_type`` to it, b) patches the ``etp_custom_slots`` table in
    response to inheritance, c) calls ``PyType_Ready``,
    d) updates ``tp_flags``.

    **Note**: In the current implementation, subclassing from another
    extensible type (step d) is simply not implemented, and will raise
    an exception. This support can be added when it is needed.

``PyTypeObject *PyExtensibleType_Import()``
    Get hold of the ``extensibletype`` metaclass directly. There's normally no
    need to call this.
    

Subclassing
'''''''''''

*Statically allocated C subclasses:* Since ``etp_custom_slots`` is
statically allocated, it should be over-allocated and padded with
slots with ``0`` as ID. The number of non-zero slots should be filled
in ``etp_count``, while the table size is passed to
``PyExtensibleType_Ready``. The table is then modified to inherit the
custom slots just like the built-in slots:

 - Slots are inherited from the parent class by prepending them to the
   table. The (id, flags, data)-struct is simply copied by value -- it
   is assumed that the data pointer will stay alive

 - If the same ID is present in the custom slot table of the child,
   the parent slot is not inherited

 - If the final number of slots is larger than the count passed to
   ``PyExtensibleType_Ready``, an exception is raised.

*Heap-allocated Python classes:* The metaclass ensures that the custom
slots of the parent is copied also to Python classes inheriting from
classes with custom slots. However, there is no mechanism for changing
the table of custom slots (the table pointer is simply set to the
table of the superclass).

Libraries can however subclass the ``extensibletype`` metaclass in
order to (somehow) provide the ability for Python subclasses to
modify the table (like a ``__customslots__`` class attribute or
similar).

Benchmark results
-----------------

The penalty of a branch-predicted table lookup in a micro-benchmark
was 1.08 ns on a 1.87 GHz (Intel Core i7 Q 840).

Changing to a format where the table was embedded directly, loosing
one pointer indirection, did not change the numbers at all.  Also,
because the var-object resizeability is already used up for the method
table in heap-allocated types, this would be somewhat intricated.

There was no difference between checking ``ob_type->tp_flags`` and
checking for a metaclass; ``ob_type->ob_type``.  For the metaclass
checking strategy, there was no difference between only being able to
match the metaclass itself, or also having the possibility of matching
a metaclass subclass (as long as that possibility isn't taken,
i.e. the direct match is ``likely``).



The custom slot ID space
------------------------

The most significant 8 bits of the ``uint32_t`` denote a
"registrar". Each registrar determines the use of the remaining 24
bits, but a recommendation, from most to least significant, is:

 * 8 bits: Registrar (required)
 * 16 bits: Which custom slot "idea"
 * 8 bits: Which backwards-incompatible version of the idea

Backwards-compatible changes should be noted in the ``flag`` field
rather than the ID.

When lookup up a slot following this recommendation, one should
therefore ``&`` the ID with the proper mask for the flags,
which is the purpose of the ``mask`` argument to ``PyCustomSlots_Find``
(that is, to match any flags, pass ``0xffffff00``).

Special IDs:

 * 0x00000000: Reserved for now
 * 0x00000001: Use if pre-padding the table is needed

ID space (most significant 8 bits):

 * 0x00: Reserved
 * 0x01: For internal/personal use, never use in released libraries
 * 0x02: NumFOCUS SEPs, NumPy, SciPy
 * 0x03: Cython
 * 0x04-...: Whoever asks

The ID space is intentially kept tight for now; because eventually one
may want to dynamically allocate such IDs (like a dynamic interface
interning scheme).

Discussion
----------

Hijacking bit 22 in ``tp_flags`` has the following advantages:

 - Consumers don't have to call any ``PyCustomSlots_Init`` to import
   a reference to the metaclass
 
 - Consumers don't have to carry along a metaclass implementation just
   in case they are imported before the first provider. (Keep in mind
   that if the NumPy C API is refactored to be based on this mechanism,
   there will be a lot of consumers.)

 - It is (probably) microscopically faster if you need to subclass the
   metaclass for some reason. No effect if you're not subclassing the
   metaclass though (due to branch prediction working its wonders)

The disadvantage is of course that we hijack a flag, and we have no guarantee
that other Python libraries are not doing the same.

At any rate, if a new Python version uses all available flag bits (and
this SEP is not accomodated by any PEPs in the meantime), one can
switch to walking ``ob_type`` and ``tp_base`` rather than checking
``tp_flags``.

As for inclusion as a PEP, that only works for new Python versions.
Python-dev was consulted on the question [#]_, and Nick Coghlan's
response [#]_ indicated that a PEP might not be entirely impossible
but should require a working implementation based on meta-classes
first.


.. [#] http://mail.python.org/pipermail/python-dev/2012-May/119481.html
.. [#] http://mail.python.org/pipermail/python-dev/2012-May/119518.html
